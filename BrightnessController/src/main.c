/**
 * Brightness controller - behaviour predominantly based on the Bluetooth mesh Generic OnOff Client Model
 * 
 * Coded for and tested with nRF52840 DK board using nrf Connect SDK 1.9.1
 * 
 **/

#include <drivers/gpio.h>
#include <bluetooth/bluetooth.h>
#include <bluetooth/mesh.h>
#include <settings/settings.h>
#include <bluetooth/mesh/proxy.h>
#include <random/rand32.h>

// GPIO for the buttons - see zephyr samples/button for origin of some of this code
// Get button configuration from the devicetree sw0 alias. This is mandatory.

// Button 1
#define SW0_NODE	DT_ALIAS(sw0)
#if !DT_NODE_HAS_STATUS(SW0_NODE, okay)
#error "Unsupported board: sw0 devicetree alias is not defined"
#endif
static const struct gpio_dt_spec button1 = GPIO_DT_SPEC_GET_OR(SW0_NODE, gpios,
							      {0});
static struct gpio_callback gpio_btn1_cb;

#ifndef SW0_GPIO_FLAGS
#ifdef SW0_GPIO_PIN_PUD
#define SW0_GPIO_FLAGS SW0_GPIO_PIN_PUD
#else
#define SW0_GPIO_FLAGS 0
#endif
#endif

// Button 2
#define SW1_NODE	DT_ALIAS(sw1)
#if !DT_NODE_HAS_STATUS(SW1_NODE, okay)
#error "Unsupported board: sw1 devicetree alias is not defined"
#endif
static const struct gpio_dt_spec button2 = GPIO_DT_SPEC_GET_OR(SW1_NODE, gpios,
							      {0});
static struct gpio_callback gpio_btn2_cb;

#ifndef SW1_GPIO_FLAGS
#ifdef SW1_GPIO_PIN_PUD
#define SW1_GPIO_FLAGS SW1_GPIO_PIN_PUD
#else
#define SW1_GPIO_FLAGS 0
#endif
#endif

// Button 3
#define SW2_NODE	DT_ALIAS(sw2)
#if !DT_NODE_HAS_STATUS(SW2_NODE, okay)
#error "Unsupported board: sw2 devicetree alias is not defined"
#endif
static const struct gpio_dt_spec button3 = GPIO_DT_SPEC_GET_OR(SW2_NODE, gpios,
							      {0});
static struct gpio_callback gpio_btn3_cb;

#ifndef SW2_GPIO_FLAGS
#ifdef SW2_GPIO_PIN_PUD
#define SW2_GPIO_FLAGS SW2_GPIO_PIN_PUD
#else
#define SW2_GPIO_FLAGS 0
#endif
#endif

// Button 4
#define SW3_NODE	DT_ALIAS(sw3)
#if !DT_NODE_HAS_STATUS(SW3_NODE, okay)
#error "Unsupported board: sw3 devicetree alias is not defined"
#endif
static const struct gpio_dt_spec button4 = GPIO_DT_SPEC_GET_OR(SW3_NODE, gpios,
							      {0});
static struct gpio_callback gpio_btn4_cb;

#ifndef SW3_GPIO_FLAGS
#ifdef SW3_GPIO_PIN_PUD
#define SW3_GPIO_FLAGS SW3_GPIO_PIN_PUD
#else
#define SW3_GPIO_FLAGS 0
#endif
#endif

#define BUTTON_DEBOUNCE_DELAY_MS 250

// for debouncing the four buttons
static uint32_t btn_time[4] = { 0,0,0,0};
static uint32_t btn_last_time[4] = { 0,0,0,0};

static struct gpio_callback gpio_btn1_cb;
static struct gpio_callback gpio_btn2_cb;
static struct gpio_callback gpio_btn3_cb;
static struct gpio_callback gpio_btn4_cb;

// GPIO for LED 0
static struct gpio_dt_spec led = GPIO_DT_SPEC_GET_OR(DT_ALIAS(led0), gpios,
						     {0});

// for use with k_work_submit which we use to handle button presses in a background thread to avoid holding onto an IRQ for too long
static struct k_work button1_work;
static struct k_work button2_work;
static struct k_work button3_work;
static struct k_work button4_work;

static uint8_t dev_uuid[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00,0x00, 0x00, 0x00, 0x00 };

static uint8_t onoff_tid;

void gen_uuid() {
    uint32_t rnd1 = sys_rand32_get();
    uint32_t rnd2 = sys_rand32_get();
    uint32_t rnd3 = sys_rand32_get();
    uint32_t rnd4 = sys_rand32_get();

    dev_uuid[15] = (rnd1 >> 24) & 0x0FF;
    dev_uuid[14] = (rnd1 >> 16) & 0x0FF;
    dev_uuid[13] = (rnd1 >>  8) & 0x0FF;
    dev_uuid[12] =  rnd1 & 0x0FF;

    dev_uuid[11] = (rnd2 >> 24) & 0x0FF;
    dev_uuid[10] = (rnd2 >> 16) & 0x0FF;
    dev_uuid[9] = (rnd2 >>  8) & 0x0FF;
    dev_uuid[8] =  rnd2 & 0x0FF;

    dev_uuid[7] = (rnd3 >> 24) & 0x0FF;
    dev_uuid[6] = (rnd3 >> 16) & 0x0FF;
    dev_uuid[5] = (rnd3 >>  8) & 0x0FF;
    dev_uuid[4] =  rnd3 & 0x0FF;

    dev_uuid[3] = (rnd4 >> 24) & 0x0FF;
    dev_uuid[2] = (rnd4 >> 16) & 0x0FF;
    dev_uuid[1] = (rnd4 >>  8) & 0x0FF;
    dev_uuid[0] =  rnd4 & 0x0FF;

    /* Set 4 MSB bits of time_hi_and_version field */
    dev_uuid[6] &= 0x0f;
    dev_uuid[6] |= 4 << 4;

    /* Set 2 MSB of clock_seq_hi_and_reserved to 10 */
    dev_uuid[8] &= 0x3f;
    dev_uuid[8] |= 0x80;

}

void ledOn(void) {
	gpio_pin_set(led.port, led.pin, 1);
}

void ledOff(void) {
	gpio_pin_set(led.port, led.pin, 0);
}

static void attention_on(struct bt_mesh_model *model)
{
	printk("attention_on()\n");
	ledOn();
}

static void attention_off(struct bt_mesh_model *model)
{
	printk("attention_off()\n");
	ledOff();
}


static const struct bt_mesh_health_srv_cb health_srv_cb = {
	.attn_on = attention_on,
	.attn_off = attention_off,
};

// provisioning properties and capabilities
	/**
	 * @brief The function provisioning_output_pin simply outputs the PIN generated by the stack to the console.
		Other devices might have more sophisticated UI options. The serial console is good enough for our purposes.
	 * 
	 * @param action 
	 * @param number 
	 * @return int 
	 */
	static int provisioning_output_pin(bt_mesh_output_action_t action, uint32_t number) {
		printk("OOB Number: %04d\n", number);
		return 0;
	}

	/**
	 * @brief provisioning_complete just outputs a message to the console to indicate that provisioning has finished.
	 * 
	 * @param net_idx 
	 * @param addr 
	 */
	static void provisioning_complete(uint16_t net_idx, uint16_t addr) {
 		printk("Provisioning completed\n");
	}

	/**
	 * @brief reset is called when provisioning was not completed (e.g. abandoned by the user). In this function,
		we restart the advertising of unprovisioned device beacons.
	 */
	static void provisioning_reset(void){
		bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT);
	}
	
	/**
	 * @brief When a device is available for provisioning, it will advertise unprovisioned device beacons. 
	 * These special advertising packets include a device UUID which identifies the device. 
	 * The value of device UUID is set by the manufacturer in the factory. 
	 * For convenience, a suitable value has been hardcoded in the starter code and this is referenced in the struct’s uuid property.
	 * There are a number of ways in which an unprovisioned device may authenticate itself to the user
	 * during the provisioning process. We want to offer the user the option to have the device
	 * authenticate itself by displaying a 4 digit PIN. The property output_actions indicates that this is the
	 * case, with output_size specifying the required PIN length. The function specified as the
	 * output_number property will be called with a random PIN generated by the stack for display to theuser.
	 * The complete and reset properties name functions to be called when provisioning has either completed or been abandoned, respectively.
	 */
	static const struct bt_mesh_prov prov = {
		.uuid = dev_uuid,
		.output_size = 4,
		.output_actions = BT_MESH_DISPLAY_NUMBER,
		.output_number = provisioning_output_pin,
		.complete = provisioning_complete,
		.reset = provisioning_reset,
	};

// -------------------------------------------------------------------------------------------------------
// Health Server
// -------------
	BT_MESH_HEALTH_PUB_DEFINE(health_pub, 0);
	/** 
	@brief This model can publish diagnostics messages and so we start by using the Zephyr SDK
	BT_MESH_HEALTH_PUB_DEFINE macro to define a publication context. We then define a context for
	the model with a struct of type bt_mesh_health_srv. We’ll use each of these items when we declare
	the models our node supports. 
	*/
	static struct bt_mesh_health_srv health_srv = {
		.cb = &health_srv_cb,
	};

// -------------------------------------------------------------------------------------------------------
// Generic OnOff Client Model
// --------------------------

uint8_t onoff[] = {
	0,
	1,
	2};

// generic on off client - handler functions for this model's RX messages

	/**
	@brief Generic onoff status messages received by this device will cause a call to the generic_onoff_status
	function because we registered it as a handler for messages with that opcode in a
	bt_mesh_model_op struct below.
	*/
	static void generic_onoff_status (struct bt_mesh_model *model, struct bt_mesh_msg_ctx *ctx,struct net_buf_simple *buf)
	{
		uint8_t level = net_buf_simple_pull_u8(buf);
		printk("Led status of the node with the address 0x%04x is : %d%%>>\n",ctx->addr,level); 
	}

// generic on off client - message types defined by this model.

	//message opcode definition : (an opcode (abbreviated from operation code, also known as instruction machine code) 
	//is the portion of a machine language instruction that specifies the operation to be performed.)
	/*
	We define constants for each of the message types that are part of the generic onoff client
	model and will be referencing them elsewhere in our code as we complete the node composition.
	*/
	#define BT_MESH_MODEL_OP_GENERIC_ONOFF_GET	BT_MESH_MODEL_OP_2(0x82, 0x01)
	#define BT_MESH_MODEL_OP_GENERIC_ONOFF_SET	BT_MESH_MODEL_OP_2(0x82, 0x02)
	#define BT_MESH_MODEL_OP_GENERIC_ONOFF_SET_UNACK	BT_MESH_MODEL_OP_2(0x82, 0x03)
	#define BT_MESH_MODEL_OP_GENERIC_ONOFF_STATUS	BT_MESH_MODEL_OP_2(0x82, 0x04)
	
	/**
	@brief This array of bt_mesh_model_op types contains a single significant member item, which specifies the
	opcode for the Generic OnOff Status message, the only type of message which our Generic OnOff
	Client must be able to receive and process. It specifies that access message payloads must be at least
	1 octet long and indicates that a function called generic_onoff_status must handle all such messages
	received.
	// each array member contains opcode, min msg len, handler function
	*/
	static const struct bt_mesh_model_op gen_onoff_cli_op[] = {
 		{BT_MESH_MODEL_OP_GENERIC_ONOFF_STATUS, 1, generic_onoff_status},
 		BT_MESH_MODEL_OP_END,
	};	

// -------------------------------------------------------------------------------------------------------
// Composition
// -----------

	BT_MESH_MODEL_PUB_DEFINE(gen_onoff_cli, NULL, 2);
	/**
	 * @brief We create an array of model definitions using the Zephyr SDK bt_mesh_model type and using
		macros from the SDK which make it easy to define special models like the configuration server
		model and the health server model. We use a general purpose model definition macro to define
		the generic onoff client model. As you can see, these definitions reference the other definitions we
		prepared earlier on. We’ve also defined a model publication context for the generic on off client
		model so that we can set and use various message publication states.
	 */
	static struct bt_mesh_model sig_models[] = { // Array storing the different models used in the application 
 		BT_MESH_MODEL_CFG_SRV, // Configuration
 		BT_MESH_MODEL_HEALTH_SRV(&health_srv, &health_pub), // Health
 		BT_MESH_MODEL(BT_MESH_MODEL_ID_GEN_ONOFF_CLI, gen_onoff_cli_op, & gen_onoff_cli, &onoff[0]), // OnOff
	};
	/**
	 * @brief We use the Zephyr SDK’s BT_ELEM_MACRO to define an element and indicate that it contains
		the models we defined in the sig_models array. We also define a struct called comp (for
		‘composition’) which effectively acts as the top of a hiererchical definition of the node and its
		composition, starting with the elements directly owned by the node. This struct also specifies a
		Company ID (CID) of 0xFFFF. This is a special value which must only be used during testing. For
		products to be released, a value must be assigned for your company by the Bluetooth SIG.
	*/
	static struct bt_mesh_elem elements[] = {
	// node contains elements. Note that BT_MESH_MODEL_NONE means "none of this type" and here means "no vendor models"
		BT_MESH_ELEM(0, sig_models, BT_MESH_MODEL_NONE),
	};
	// node
	static const struct bt_mesh_comp comp = {
		.cid = 0xFFFF,
		.elem = elements,
		.elem_count = ARRAY_SIZE(elements),
	};

// Generic OnOff Client - TX message producer functions
// -----------------------------------------------------------
	/**
	 * @brief We first check that a model publish address has been configured. If there has not, we ignore the call and return immediately.
		Using the Zephyr APIs, we acquire a buffer for our message from the generic on off client model and
		prepare it for use by calling bt_mesh_model_msg_init. In the case of other message types, we might
		have needed to set some message argument values in the buffer but in this case we do not need to
		since generic on off get has no arguments.
		bt_mesh_model_publish(model) causes our message to be published.
	 * 
	 * @return int 
	 */
	int genericOnOffGet (){
		printk("\n\ngenericOnOffGet\n");
		int err;
		struct bt_mesh_model *model = &sig_models[2];
		if (model->pub->addr == BT_MESH_ADDR_UNASSIGNED){
			printk("No publish address associated with the generic on off client model\n");
			return -1;
		}
		struct net_buf_simple *msg = model->pub->msg;

		bt_mesh_model_msg_init(msg,BT_MESH_MODEL_OP_GENERIC_ONOFF_GET);
		printk("publishing get on off message\n");
		err = bt_mesh_model_publish(model);
		if (err){
			printk("bt_mesh_model_publish err %d\n", err);
		}
		return err;
	}


	/**
	 * @brief The function takes two parameters, the first of which is the onoff state value which should be 0 or a
		1. The second is an opcode which will indicate which of generic onoff set or generic onoff set
		unacknowledged we wish to send.
		Once again, we check for a publish address for this model, acquire a message buffer and initialise it.
		We add the onoff state and TID (Transaction Identifier) values to the message buffer using the
		Zephyr function net_buf_simple_add_u8, increment the TID in readiness for publishinging our next
		message and then publish the message using the Zephyr bt_mesh_model_publish function.
	 * 
	 * @param on_or_off 
	 * @param message_type 
	 * @return int 
	 */
	int sendGenOnOffSet (uint8_t on_or_off, uint16_t message_type)
	{
		int err;
		struct bt_mesh_model *model = &sig_models[2];
		if (model->pub->addr == BT_MESH_ADDR_UNASSIGNED) {
			printk("No publish address associated with the generic on off client model\n");
			return -1;
		}
		struct net_buf_simple *msg = model->pub->msg; // Creation of a buffer to store the message
		bt_mesh_model_msg_init(msg,message_type); // Adding the type of message 
		net_buf_simple_add_u8(msg,on_or_off); // Adding wanted state 
		net_buf_simple_add_u8(msg,onoff_tid); // Adding transaction ID 
		onoff_tid++;
		printk("\npublishing set on off state=0x%02x\n",on_or_off);
		err = bt_mesh_model_publish(model);
		if (err) {
			printk("bt_mesh_model_publish err %d\n", err);
		}
		return err;
	}

	void genericOnOffSet(uint8_t on_or_off){
		if (sendGenOnOffSet(on_or_off, BT_MESH_MODEL_OP_GENERIC_ONOFF_SET)){ 
			printk("Unable to send generic onoff set message\n");
		}else{
			// From the value of "on_or_off" variable, we display which kind of message was sent
			switch (on_or_off)
			{
			case 0:
				printk("Decrease LEDs brightness");
				break;
			case 1:
				printk("Increase LEDs brightness");
				break;
			case 2:
				printk("Turning off LEDs");
				break;
			default:
				printk("Wrong value");
				break;
			}
		}

	}

	void genericOnOffSetUnAck(uint8_t on_or_off){
		if (sendGenOnOffSet(on_or_off, BT_MESH_MODEL_OP_GENERIC_ONOFF_SET_UNACK)){ 
			printk("Unable to send generic onoff set unack message\n");
		}else{
			// From the value of "on_or_off" variable, we display which kind of message was sent
			switch (on_or_off)
			{
			case 0:
				printk("Decrease LEDs brightness");
				break;
			case 1:
				printk("Increase LEDs brightness");
				break;
			case 2:
				printk("Turning off LEDs");
				break;
			default:
				printk("Wrong value");
				break;
			}
		}
	}

// Buttons
// -------

// The use of the first button will increase the LEDs' brightness
void button1_work_handler(struct k_work *work)
{
	genericOnOffSetUnAck(onoff[1]);
	// genericOnOffSet(onoff[1]);
}

// The use of the second button will decrease the LEDs' brightness
void button2_work_handler(struct k_work *work)
{
	genericOnOffSetUnAck(onoff[0]);
	// genericOnOffSet(onoff[0]);
}

// The use of the third button will ask for the LEDs' current brightness level
void button3_work_handler(struct k_work *work)
{	
	genericOnOffGet();
}

// The use of the fourth button will turn off the LEDs
void button4_work_handler(struct k_work *work)
{
	genericOnOffSetUnAck(onoff[2]);
	// genericOnOffSet(onoff[2]);
}

bool debounce(int btn_inx) {
	bool ignore = false;
	btn_time[btn_inx] = k_uptime_get_32();
	if (btn_time[btn_inx] < (btn_last_time[btn_inx] + BUTTON_DEBOUNCE_DELAY_MS)) {
		ignore = true;
	} else {
		ignore = false;
	}
	btn_last_time[btn_inx] = btn_time[btn_inx];
	return ignore;
}

void button_1_pressed(const struct device *gpiob, struct gpio_callback *cb,
											uint32_t pins)
{
	// printk("Button 1 pressed at %d\n", k_cycle_get_32());

    if (!debounce(0)) {
	  k_work_submit(&button1_work);
	}
}

void button_2_pressed(const struct device *gpiob, struct gpio_callback *cb,
											uint32_t pins)
{
	// printk("Button 2 pressed at %d\n", k_cycle_get_32());
    if (!debounce(1)) {
	  k_work_submit(&button2_work);
	}
}

void button_3_pressed(const struct device *gpiob, struct gpio_callback *cb,
											uint32_t pins)
{
	// printk("Button 3 pressed at %d\n", k_cycle_get_32());
    if (!debounce(2)) {
	  k_work_submit(&button3_work);
	}
}

void button_4_pressed(const struct device *gpiob, struct gpio_callback *cb,
											uint32_t pins)
{
	// printk("Button 4 pressed at %d\n", k_cycle_get_32());
    if (!debounce(3)) {
	  k_work_submit(&button4_work);
	}
}

// -------------------------------------------------------------------------------------------------------
// LED
// -------
/**
 * @brief This function sets up GPIO to allow the board’s built-in LED to be switched on or off and switches it off to
begin with.
 */
void configureLED(void)
{
	printk("configureLED\n");

	int ret = 0;

	if (led.port && !device_is_ready(led.port)) {
		printk("Error %d: LED device %s is not ready; ignoring it\n",
		       ret, led.port->name);
		led.port = NULL;
	}
	if (led.port) {
		ret = gpio_pin_configure_dt(&led, GPIO_OUTPUT);
		if (ret != 0) {
			printk("Error %d: failed to configure LED device %s pin %d\n",
			       ret, led.port->name, led.pin);
			led.port = NULL;
		} else {
			printk("Set up LED at %s pin %d\n", led.port->name, led.pin);
		}
	}

	// LED 0
	ledOff();
}


// -------------------------------------------------------------------------------------------------------
// Buttons
// -------

/**
 * @brief This sets up GPIO so that pressing any of the four buttons on the board results in a callback to an
	associated handler function
 */
void configureButtons(void)
{
	printk("configureButtons\n");

	int ret;

	// Button 1
	k_work_init(&button1_work, button1_work_handler);
	ret = gpio_pin_configure_dt(&button1, GPIO_INPUT);
	if (ret != 0) {
		printk("Error %d: failed to configure %s pin %d\n",
		       ret, button1.port->name, button1.pin);
		return;
	}

	ret = gpio_pin_interrupt_configure_dt(&button1,
					      GPIO_INT_EDGE_TO_ACTIVE);
	if (ret != 0) {
		printk("Error %d: failed to configure interrupt on %s pin %d\n",
			ret, button1.port->name, button1.pin);
		return;
	}

	gpio_init_callback(&gpio_btn1_cb, button_1_pressed, BIT(button1.pin));
	gpio_add_callback(button1.port, &gpio_btn1_cb);
	printk("Set up button at %s pin %d\n", button1.port->name, button1.pin);

	// Button 2
	k_work_init(&button2_work, button2_work_handler);
	ret = gpio_pin_configure_dt(&button2, GPIO_INPUT);
	if (ret != 0) {
		printk("Error %d: failed to configure %s pin %d\n",
		       ret, button2.port->name, button2.pin);
		return;
	}

	ret = gpio_pin_interrupt_configure_dt(&button2,
					      GPIO_INT_EDGE_TO_ACTIVE);
	if (ret != 0) {
		printk("Error %d: failed to configure interrupt on %s pin %d\n",
			ret, button2.port->name, button2.pin);
		return;
	}

	gpio_init_callback(&gpio_btn2_cb, button_2_pressed, BIT(button2.pin));
	gpio_add_callback(button2.port, &gpio_btn2_cb);
	printk("Set up button at %s pin %d\n", button2.port->name, button2.pin);

	// Button 3
	k_work_init(&button3_work, button3_work_handler);
	ret = gpio_pin_configure_dt(&button3, GPIO_INPUT);
	if (ret != 0) {
		printk("Error %d: failed to configure %s pin %d\n",
		       ret, button3.port->name, button3.pin);
		return;
	}

	ret = gpio_pin_interrupt_configure_dt(&button3,
					      GPIO_INT_EDGE_TO_ACTIVE);
	if (ret != 0) {
		printk("Error %d: failed to configure interrupt on %s pin %d\n",
			ret, button3.port->name, button3.pin);
		return;
	}

	gpio_init_callback(&gpio_btn3_cb, button_3_pressed, BIT(button3.pin));
	gpio_add_callback(button3.port, &gpio_btn3_cb);
	printk("Set up button at %s pin %d\n", button3.port->name, button3.pin);

	// Button 4
	k_work_init(&button4_work, button4_work_handler);
	ret = gpio_pin_configure_dt(&button4, GPIO_INPUT);
	if (ret != 0) {
		printk("Error %d: failed to configure %s pin %d\n",
		       ret, button4.port->name, button4.pin);
		return;
	}

	ret = gpio_pin_interrupt_configure_dt(&button4,
					      GPIO_INT_EDGE_TO_ACTIVE);
	if (ret != 0) {
		printk("Error %d: failed to configure interrupt on %s pin %d\n",
			ret, button4.port->name, button4.pin);
		return;
	}

	gpio_init_callback(&gpio_btn4_cb, button_4_pressed, BIT(button4.pin));
	gpio_add_callback(button4.port, &gpio_btn4_cb);
	printk("Set up button at %s pin %d\n", button4.port->name, button4.pin);

}

/**
 * @brief bt_ready is called after the Bluetooth stack has been initialised and so the first task is to verify that this was successful by checking the value of the err parameter.
	We then initialise the mesh stack by calling bt_mesh_init with our provisioning and node composition structs as arguments.
	Next, we call settings_load(), which restores persisted data including mesh stack variables such as the SEQ field (so we can continue from the last allocated value) 
	and provisioning data such as the network key and application key, if the device has already been provisioned.
	We check whether or not the node has already been provisioned, using the function bt_mesh_is_provisioned() and if it has not generate a random device UUID value and start
	broadcasting unprovisioned device beacons (which include the UUID) by calling bt_mesh_prov_enable(). The arguments BT_MESH_PROV_ADV | BT_MESH_PROV_GATT indicate
	that provisioning may be performed using either the advertising bearer or the GATT bearer.
 * 
 * @param err 
 */
static void bt_ready(int err)
{
	if (err)
	{
		printk("bt_enable init failed with err %d\n", err);
		return;
	}
	printk("Bluetooth initialised OK\n");

	// prov is a bt_mesh_prov struct and is declared in provisioning.c
	err = bt_mesh_init(&prov, &comp);
	if (err)
	{
		printk("bt_mesh_init failed with err %d\n", err);
		return;
	}
	printk("Mesh initialised OK\n");

	if (IS_ENABLED(CONFIG_SETTINGS)) {
		settings_load();
 		printk("Settings loaded\n");
	}
 
 	if (!bt_mesh_is_provisioned()) {
 		printk("Node has not been provisioned - beaconing\n");
		gen_uuid();
		printk("\n%02X%02X%02X%02X-%02X%02X-%02X%02X-%02X%02X-%02X%02X%02X%02X%02X%02X\n\n",
			dev_uuid[15], dev_uuid[14], dev_uuid[13], dev_uuid[12],dev_uuid[11], dev_uuid[10], dev_uuid[9], dev_uuid[8],
			dev_uuid[7], dev_uuid[6], dev_uuid[5], dev_uuid[4],dev_uuid[3], dev_uuid[2], dev_uuid[1], dev_uuid[0]);
		bt_mesh_prov_enable(BT_MESH_PROV_ADV | BT_MESH_PROV_GATT);
	} else {
 		printk("Node has already been provisioned\n");
 		printk("Node unicast address: 0x%04x\n",elements[0].addr);
	}
}


void main(void)
{
	int err;
	printk("NRF52840 Client (Buttons) \n");

	onoff_tid = 0;

	configureButtons();

	configureLED();
	
	//bt_enable is a Zephyr API function which enables Bluetooth. On completion, the system makes a callback to the function provided as an argument, in our case, the function bt_ready.
	err = bt_enable(bt_ready);

	if (err){
		printk("bt_enable failed with err %d\n", err);
	}
}
